INDEES  
Definition: The index provides a location of data so that the users can go directly to the data.  
Types of Indexes : Three categories described: heaps, clustered indexes, and nonclustered indexes. Heap and clustered indexes directly affect how data in their underlying tables are stored. Nonclustered indexes are independent of row storage.  1.Heap Tables​ : When the data is small. There is no structure maintained for them. This lack of a structured and searchable indexing scheme is referred to as a heap.In a heap, the first row added to the index is the first record in the table, the second row is the second record in the table, the third row is the third record in the table, and so on. There is nothing in the data that is used to specify the order in which the data has been added. The data and records are in the table without any particular order.When a table is first created, the initial storage structure is called a heap. This is probably the simplest storage structure. Rows are inserted into the table in the order in which they are added. A table will use a heap until a clustered index is created on the table (we’ll discuss clustered indexes in the next section). A table can either be a heap or a clustered index, but not both. Also, there is only a single heap structure allowed per table.  2.Clustered Index ​: The Indexed created column is known as key column .A clustered index stores the records in the table based on the order of the key columns of the index. The column(s) used as the key columns for a clustered index are selected based on the most frequently used data path to the records in the table. With many tables, the primary key or business key will often function as the clustered index clustering key. ​In a clustered index, the data outside the key columns is stored alongside the key columns. ​This equates to the clustered index as being the physical table itself, just as a heap defines the table. The primary key will be clustered by default​, but this behavior can be overridden and will be ignored if a clustered index already exists.  Reason for only one cluster index :​ Also, since a clustered index defines how the data in a table is stored, a table cannot have more than one clustered index.  3.Non Clustered Indexes​ : In a non clustered index, columns are selected and sorted based on their values. These columns contain a reference to the clustered index or heap location of the data they are related to. This is nearly identical to how a card catalog works in a library. The order of the books, or the records in the tables, doesn’t change, but a shortcut to the data is created based on the other search values. There can be many nonclustered indexes on a table, in fact up to ​ nonclustered indexes​.  
4.ColumnStore Index ​: Traditionally, indexes are stored in row based organization, also known as row store. This form of storage is extremely efficient when one row or a small range is requested. When a large range or all rows are returned, this organization can become inefficient. The column store index favors the return of large ranges of rows by storing data in column-wise organization. When you create a column store index, you typically include all the columns in a table. This ensures that all columns are included in the enhanced performance benefits of the column store organization. In a column store index, instead of storing all of the columns for a record together, each column is stored separately with all of the other rows in an index. The benefit of this type of index is that only the columns and rows required for a query need to be read. Column store indexes do have a few restrictions on them when compared to other indexes. To begin with, data modifications, such as those through INSERT, UPDATE, and DELETE statements, are disallowed. For this reason, column store indexes are ideally situated for large data warehouses where the data is not changed that frequently. They also take significantly longer to create; at the time of this writing, they average two to three times longer than the time to create a similar nonclustered index.  5.Full Text Index​ :Consider for a moment if every book in the library had a keyword index. Furthermore, let’s take all of those keywords and place them in their own card catalog. With this card catalog, you’d be able to find every book in the library with references to every page that discusses full-text searches. Generally speaking, this is what an implementation of a full-text search provides.  
● Typically, a primary key will be created on a single column, though it can be composed of multiple columns.  
Difference between unique and primary index: One chief difference between a primary key and a unique index is the behavior when the possibility of null values is introduced. A ​unique index​ will ​allow null ​values within the columns being indexed. A null value is considered a discrete value, and ​only one null value is allowed in a unique index.  
Included columns: Including information outside the indexed columns is done through included columns.When a nonclustered index is built, there is an option to add included columns into the index. These columns are stored as nonsorted data within the sorted data in the index. Included columns cannot include any columns that have been used in the initial sorted column list of the index. Included columns can significantly improve the performance of a query.  
Partitioned Index: Books that cover a lot of data can get fairly large. If you look at a dictionary or the complete works on William Shakespeare, these are often quite thick. Books can get large enough that the idea of containing them in a single volume just isn’t practical. The best example of this is an encyclopedia. It is rare that an encyclopedia is contained in a single book. The reason is quite 
simple—the size of the book and the width of the binding would be beyond the ability of nearly anyone to manage. Also, the time it takes to find all of the subjects in the encyclopedia that start with the letter “S” is greatly improved because you can go directly to the “S” volume instead of paging through an enormous book to find where they start. This problem isn’t limited to books. A problem similar to this exists with tables as well. Tables and their indexes can get to a point where their size makes it difficult to continue to maintain the indexes in a reasonable time period. Along with that, if the table has millions or billions of rows, being able to scan across limited portions of the table vs. the whole table can provide significant performance improvements. To solve this problem on a table, indexes have the ability to be partitioned. Partitioning can occur on both clustered and nonclustered indexe​s. It allows an index to be split along the values supplied by a function. By doing this, the data in the index is physically separated into multiple partitions, while the​ index itself is still a single logical obect​.  Filtered Index:  Nonclustered indexes can be filtered to reduce the number of records they contain. When the index is built, it can be defined to include or exclude records based on a simple comparison that reduces the size of the index. Besides the performance improvements outlined, there are other benefits in using filtered indexes. The first improvement is reduced storage costs. Since filtered indexes have fewer records in them, due to the filtering, there will be less data in the index, which requires less storage space. The other benefit is reduced maintenance costs. Similar to the reduced storage costs, since there is less data to maintain, less time is required to maintain the index.  
